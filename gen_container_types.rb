if ARGV.count < 1
    puts 'Pass in the output/input directory followed by any additional input directories'
    puts '[--preset] in/out [in, ...]'
    exit
end

if ARGV[0] == '--preset' and ARGV.count >= 2
    preset = true
    inputs = ARGV[1..-1].join(',')
    output = ARGV[1]
else
    preset = false
    inputs = ARGV.join(',')
    output = ARGV[0]
end

containers = []

Dir["{#{inputs}}/**/*.h"].each { |file|
    src = File.read(file)
    src.scan(/^\s*?#define\s*?CC_(.*?)\s*?\(.*?\)\s*?CC_CONTAINER\(/).each { |define|
        containers << 'CC_' + define[0]
        containers <<  'CC' + define[0].split('_').map { |s| s.capitalize }.join
    }
}

private_types = {}
match = /^[^#\n]*?[^\w]*?(#{containers.join('|')})(\((?>[\w\s,]+|\g<2>)*\))/

if containers.count > 0
    Dir["#{output}/**/*.{c,m}"].each { |file|
        src = File.read(file)
        src.scan(match).each { |type|
            if type[0].include? '_'
                container = type[0].split('_').map { |s| s.capitalize }.join
                container = container[0..2].upcase + container[3..-1]
            else
                container = type[0]
            end
            elements = type[1][1..-2]
            (private_types[container] = private_types[container] || []) << ["CC_CONTAINER_DECLARE(#{container}, #{elements});", elements.split(',').map { |s| (s[/[^\(\)]+$/] || s[/^[^\(\)]*/]).strip }]
        }
    }
end

types = {}

if containers.count > 0
    Dir["{#{inputs}}/**/*.h"].each { |file|
        src = File.read(file)
        src.scan(match).each { |type|
            if type[0].include? '_'
                container = type[0].split('_').map { |s| s.capitalize }.join
                container = container[0..2].upcase + container[3..-1]
            else
                container = type[0]
            end
            elements = type[1][1..-2]
            (types[container] = types[container] || []) << "CC_CONTAINER_DECLARE(#{container}, #{elements});"
        }
        private_types.each_key { |k|
            private_types[k].map { |e|
                e[1].select! { |s| !src.match(/(^|\s)#{Regexp.quote(s)}([^\w]|$)/) }
            }
        }
    }
end

types.merge!(private_types) { |k, a, b| a << b.select { |e| e[1].count == 0 } }

if preset
    containers.each { |type|
        if type.include? '_'
            container = type.split('_').map { |s| s.capitalize }.join
            container = container[0..2].upcase + container[3..-1]
        else
            container = type
        end

        types[container] = types[container] || []
    }

    declarations = types.to_a.map { |e| "#define CC_CONTAINER_DECLARE_PRESET_#{e[0]}() #{e[1].count > 0 ? "\\" : ''}\n" + e[1].flatten.uniq.sort.join(" \\\n") }.sort.join("\n\n")
else
    declarations = types.to_a.map { |e| e[1].flatten.uniq.sort.join("\n") }.sort.join("\n")
end

src = """
//This file is automatically generated, modifications will be lost!
#{declarations}
""".lstrip

File.write("#{output}/ContainerTypes.h", src)
