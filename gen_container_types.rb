if ARGV.count < 1
    puts 'Pass in the output/input directory followed by any additional input directories'
    exit
end

containers = []

Dir["{#{ARGV.join(',')}}/**/*.h"].each { |file|
    src = File.read(file)
    src.scan(/^\s*?#define\s*?CC_(.*?)\s*?\(.*?\)\s*?CC_CONTAINER\(/).each { |define|
        containers << 'CC_' + define[0]
        containers <<  'CC' + define[0].split('_').map { |s| s.capitalize }.join
    }
}

private_types = []
match = /^[^#\n]*?[^\w]*?(#{containers.join('|')})(\((?>[\w\s,]+|\g<2>)*\))/

if containers.count > 0
    Dir["#{ARGV[0]}/**/*.{c,m}"].each { |file|
        src = File.read(file)
        src.scan(match).each { |type|
            if type[0].include? '_'
                container = type[0].split('_').map { |s| s.capitalize }.join
                container = container[0..2].upcase + container[3..-1]
            else
                container = type[0]
            end
            elements = type[1][1..-2]
            private_types << ["CC_CONTAINER_DECLARE(#{container}, #{elements});", elements.split(',').map { |s| (s[/[^\(\)]+$/] || s[/^[^\(\)]*/]).strip }]
        }
    }
end

types = []

if containers.count > 0
    Dir["{#{ARGV.join(',')}}/**/*.h"].each { |file|
        src = File.read(file)
        src.scan(match).each { |type|
            if type[0].include? '_'
                container = type[0].split('_').map { |s| s.capitalize }.join
                container = container[0..2].upcase + container[3..-1]
            else
                container = type[0]
            end
            elements = type[1][1..-2]
            types << "CC_CONTAINER_DECLARE(#{container}, #{elements});"
        }
        private_types.map { |e|
            e[1].select! { |s| !src.match(/(^|\s)#{Regexp.quote(s)}([^\w]|$)/) }
        }
    }
end

types << private_types.select { |e| e[1].count == 0 }

src = """
//This file is automatically generated, modifications will be lost!
#{types.flatten.uniq.sort.join("\n")}
""".lstrip

File.write("#{ARGV[0]}/ContainerTypes.h", src)
